<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Family Music Quiz</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 1100px; margin: 24px auto; padding: 0 12px; }
    button { padding: 10px 12px; margin: 6px 6px 6px 0; cursor:pointer; }
    select, input { padding: 8px; margin: 6px 6px 6px 0; }
    .box { border: 1px solid #ddd; padding: 12px; border-radius: 10px; margin-top: 12px; }
    .ok { color: #0a7a0a; }
    .bad { color: #b00020; }
    .muted { color:#666; font-size: 12px; }
    pre { white-space: pre-wrap; word-break: break-word; background:#fafafa; border:1px solid #eee; padding:10px; border-radius:8px; }
    .row { display:flex; gap:10px; flex-wrap: wrap; align-items: center; }
    .hidden { display:none !important; }
    .big { font-size: 22px; font-weight: 700; margin: 8px 0; }

    .playerRow { display:flex; gap:10px; flex-wrap: wrap; align-items:center; margin: 8px 0; padding: 8px; border: 1px dashed #ddd; border-radius: 10px; }
    .playerRow input { width: 180px; }
    .playerRow select { min-width: 360px; }

    /* Timeline UI */
    .timelineWrap { overflow-x:auto; padding-bottom: 6px; }
    .timeline { display:flex; align-items: stretch; gap: 10px; min-height: 74px; }
    .card {
      min-width: 190px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid #ddd;
      background: #fff;
    }
    .card.ok { border-color: #0a7a0a; }
    .card.bad { border-color: #b00020; }
    .slot {
      min-width: 30px;
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius: 10px;
      border: 2px dashed #ddd;
      background: #fafafa;
      user-select: none;
    }
    .slot button{
      margin:0;
      padding: 14px 10px;
      width: 100%;
      border: none;
      background: transparent;
      font-size: 18px;
      cursor:pointer;
    }
    .slot.active { border-color: #111; background:#f0f0f0; }
    .slot:hover { background:#f3f3f3; }

    .scoreboard { display:flex; gap:10px; flex-wrap:wrap; }
    .scorechip { border:1px solid #ddd; border-radius:999px; padding:6px 10px; background:#fff; }
    .scorechip.active { border-color:#111; }

    .badgeQ {
      width: 44px; height: 44px;
      border-radius: 12px;
      border: 2px solid #ddd;
      display:flex; align-items:center; justify-content:center;
      font-size: 24px;
      background: #fff;
    }

    .checkrow { display:flex; gap:14px; flex-wrap:wrap; align-items:center; margin-top:10px; }
    .checkrow label { display:flex; gap:8px; align-items:center; }

    /* BIG BUTTONS */
    .bigBtn{
      font-size: 26px;
      padding: 18px 22px;
      border-radius: 16px;
    }
    .primaryBtn{ font-weight: 800; }
    .wideBtn{ min-width: 220px; }
  </style>
</head>
<body>

<h1>Family Music Quiz</h1>

<div class="box">
  <h2>1) Verbindung</h2>
  <button id="loginBtn">Mit Spotify verbinden</button>
  <button id="logoutBtn">Logout (Token l√∂schen)</button>
  <div id="connStatus"></div>
</div>

<!-- SETUP SCREEN -->
<div id="setupScreen" class="box">
  <h2>2) Setup</h2>

  <div class="row">
    <button id="loadPlaylistsBtn">Meine Playlists laden</button>
    <button id="testMeBtn">/me testen</button>
  </div>

  <div id="setupStatus"></div>

  <div class="box" style="margin-top:10px;">
    <b>Modus w√§hlen:</b>
    <div class="row" style="margin-top:6px;">
      <label><input type="radio" name="mode" value="standard" checked> Standardmodus (Timeline, 10 richtige)</label>
      <label><input type="radio" name="mode" value="guess"> Song erraten (Titel/Interpret/Jahr ‚Üí Punkte)</label>
    </div>
    <div class="muted">
      Geteilte/‚ÄûShared‚Äú Playlists erscheinen hier, wenn du sie in Spotify <b>folgst / speicherst</b>
      oder wenn es eine <b>collaborative Playlist</b> ist.
    </div>
  </div>

  <div class="row" style="margin-top:10px;">
    <label><b>Anzahl Spieler:</b></label>
    <input id="numPlayers" type="number" min="1" max="12" value="3" />
    <button id="buildPlayersBtn">Spielerfelder erstellen</button>
  </div>

  <div id="playersForm"></div>

  <div class="row" style="margin-top:12px;">
    <button id="startGameBtn">Spiel starten</button>
    <span class="muted">Start l√§dt automatisch alle gew√§hlten Playlists vollst√§ndig (kann bei gro√üen Listen dauern).</span>
  </div>
</div>

<!-- GAME SCREEN -->
<div id="gameScreen" class="box hidden">
  <h2>3) Spiel</h2>

  <div class="row" style="justify-content:space-between;">
    <div id="turnPrompt" class="big"></div>
    <div class="scoreboard" id="scoreboard"></div>
  </div>

  <div id="turnButtons" class="row">
    <button id="readyBtn" class="bigBtn primaryBtn wideBtn">‚úÖ BEREIT!</button>
    <button id="revealBtn" class="bigBtn primaryBtn wideBtn hidden">üëÄ REVEAL!</button>

    <button id="applyPointsBtn" class="hidden">‚úÖ Punkte √ºbernehmen</button>
    <button id="nextBtn" class="hidden">‚û°Ô∏è Weiter</button>

    <button id="stopBtn">‚è∏Ô∏è Stop</button>
    <button id="endGameBtn" class="hidden">üèÅ Spiel beenden</button>
  </div>

  <div id="gameStatus" class="muted"></div>

  <!-- STANDARD MODE: Timeline -->
  <div id="timelineArea" class="box hidden" style="margin-top:10px;">
    <div class="muted">Timeline (f√ºr den aktuellen Spieler):</div>
    <div class="timelineWrap">
      <div id="timelineRow" class="timeline"></div>
    </div>

    <div class="row" id="placeControls" style="margin-top:10px;">
      <button id="leftBtn">‚¨ÖÔ∏è</button>
      <div style="display:flex; gap:12px; align-items:center;">
        <div class="badgeQ" title="Neue Karte (verdeckt)">‚ùì</div>
        <div class="muted">
          W√§hle die Einf√ºgeposition √ºber die gestrichelten Linien (Slots) oder ‚¨ÖÔ∏è/‚û°Ô∏è.<br>
          Du kannst die Position bis zum Reveal jederzeit √§ndern.
        </div>
      </div>
      <button id="rightBtn">‚û°Ô∏è</button>
      <div class="muted">Pos: <span id="posLabel"></span></div>
    </div>

    <div id="revealBox" class="box hidden" style="margin-top:10px;"></div>
  </div>

  <!-- GUESS MODE -->
  <div id="guessArea" class="box hidden" style="margin-top:10px;">
    <div class="muted">Song erraten (nach Reveal ausw√§hlen, was richtig war):</div>
    <div id="guessRevealBox" class="box hidden" style="margin-top:10px;"></div>

    <div id="guessChecks" class="checkrow hidden">
      <label><input type="checkbox" id="chkTitle"> Songtitel</label>
      <label><input type="checkbox" id="chkArtist"> Interpret</label>
      <label><input type="checkbox" id="chkYear"> Jahr</label>
      <span class="muted">(1 Punkt pro Haken)</span>
    </div>
  </div>
</div>

<!-- WINNER / END SCREEN -->
<div id="winnerScreen" class="box hidden">
  <h2>üèÅ Spiel beendet</h2>
  <div id="winnerText" class="big"></div>
  <div id="rankingBox" class="box"></div>
  <button id="restartBtn">Neues Spiel (Setup)</button>
</div>

<div class="box">
  <h2>Debug</h2>
  <pre id="debug"></pre>
</div>

<script>
/*** ‚úÖ KONFIG ***/
const clientId = "1567cc8cfec14ea2b8562efca5dd7e08";
const redirectUri = "https://skarvaan.github.io/family-music-quiz/callback.html";
const WIN_SCORE_STANDARD = 10;

const scope = [
  "playlist-read-private",
  "playlist-read-collaborative",
  "user-read-playback-state",
  "user-modify-playback-state"
].join(" ");

/*** UI refs ***/
const connStatus = document.getElementById("connStatus");
const debugEl = document.getElementById("debug");

const setupScreen = document.getElementById("setupScreen");
const setupStatus = document.getElementById("setupStatus");
const playersForm = document.getElementById("playersForm");

const gameScreen = document.getElementById("gameScreen");
const winnerScreen = document.getElementById("winnerScreen");
const winnerText = document.getElementById("winnerText");
const rankingBox = document.getElementById("rankingBox");

const turnPrompt = document.getElementById("turnPrompt");
const gameStatus = document.getElementById("gameStatus");
const scoreboardEl = document.getElementById("scoreboard");

const readyBtn = document.getElementById("readyBtn");
const revealBtn = document.getElementById("revealBtn");
const applyPointsBtn = document.getElementById("applyPointsBtn");
const nextBtn = document.getElementById("nextBtn");
const stopBtn = document.getElementById("stopBtn");
const endGameBtn = document.getElementById("endGameBtn");

const timelineArea = document.getElementById("timelineArea");
const timelineRow = document.getElementById("timelineRow");
const placeControls = document.getElementById("placeControls");
const posLabel = document.getElementById("posLabel");
const leftBtn = document.getElementById("leftBtn");
const rightBtn = document.getElementById("rightBtn");
const revealBox = document.getElementById("revealBox");

const guessArea = document.getElementById("guessArea");
const guessRevealBox = document.getElementById("guessRevealBox");
const guessChecks = document.getElementById("guessChecks");
const chkTitle = document.getElementById("chkTitle");
const chkArtist = document.getElementById("chkArtist");
const chkYear = document.getElementById("chkYear");

/*** State ***/
let mode = "standard"; // "standard" | "guess"
let playlistList = [];
let players = []; // [{name, playlistId, tracks:[], bag:[], timeline:[], score:number}]
let currentPlayerIndex = 0;

let currentSong = null;
let insertPos = 0;     // only in standard mode
let phase = "idle";    // "idle" | "placing" | "revealed"
let isPlaying = false; // for stop/play toggle

/*** helpers ***/
function setDebug(msg) { debugEl.textContent = msg || ""; }
function setConn(html) { connStatus.innerHTML = html; }
function setSetupStatus(html) { setupStatus.innerHTML = html; }
function setGameStatus(msg) { gameStatus.textContent = msg || ""; }

function getToken() { return localStorage.getItem("spotify_access_token"); }
function getScope() { return localStorage.getItem("spotify_scope") || ""; }

window.onerror = function(message, source, lineno, colno) {
  setDebug("JS ERROR:\n" + message + "\n" + source + ":" + lineno + ":" + colno);
};

function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

function refreshConnStatus() {
  const s = getScope();
  setConn(getToken()
    ? `<span class="ok">‚úÖ Verbunden (Token vorhanden)</span><br><small>Scopes: ${s || "(unbekannt)"}</small>`
    : `<span class="bad">‚ùå Nicht verbunden</span>`
  );
}

function showSetup(){
  setupScreen.classList.remove("hidden");
  gameScreen.classList.add("hidden");
  winnerScreen.classList.add("hidden");
}

function showGame(){
  setupScreen.classList.add("hidden");
  gameScreen.classList.remove("hidden");
  winnerScreen.classList.add("hidden");
}

function showWinner(title, rankingHtml){
  setupScreen.classList.add("hidden");
  gameScreen.classList.add("hidden");
  winnerScreen.classList.remove("hidden");
  winnerText.textContent = title;
  rankingBox.innerHTML = rankingHtml || "";
}

function updateStopPlayBtn(){
  stopBtn.textContent = isPlaying ? "‚è∏Ô∏è Stop" : "‚ñ∂Ô∏è Play";
}

function logout() {
  localStorage.removeItem("spotify_access_token");
  localStorage.removeItem("spotify_scope");
  localStorage.removeItem("pkce_verifier");
  localStorage.removeItem("spotify_auth_code");

  playlistList = [];
  players = [];
  currentPlayerIndex = 0;

  currentSong = null;
  insertPos = 0;
  phase = "idle";
  isPlaying = false;
  updateStopPlayBtn();

  playersForm.innerHTML = "";
  setSetupStatus("üîí Token gel√∂scht.");
  setGameStatus("");
  setDebug("");

  showSetup();
  refreshConnStatus();
}

/*** fetch helper ***/
async function apiGet(url, timeoutMs = 20000) {
  const token = getToken();
  if (!token) throw new Error("Kein Token vorhanden (bitte neu verbinden).");

  const ctrl = new AbortController();
  const timer = setTimeout(() => ctrl.abort(), timeoutMs);

  try {
    const res = await fetch(url, {
      headers: { Authorization: `Bearer ${token}` },
      signal: ctrl.signal
    });

    const text = await res.text();
    let data = null;
    try { data = text ? JSON.parse(text) : null; } catch {}

    if (!res.ok) {
      const msg = data?.error?.message || data?.error_description || text || `HTTP ${res.status}`;
      throw new Error(`Spotify API Fehler (${res.status}): ${msg}`);
    }
    return data;
  } catch (e) {
    if (e.name === "AbortError") throw new Error("Timeout: Spotify antwortet nicht (20s).");
    throw e;
  } finally {
    clearTimeout(timer);
  }
}

/*** PKCE login ***/
function randomVerifier() {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const bytes = crypto.getRandomValues(new Uint8Array(64));
  return Array.from(bytes, b => chars[b % chars.length]).join("");
}
async function sha256Base64Url(verifier) {
  const digest = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(verifier));
  return btoa(String.fromCharCode(...new Uint8Array(digest)))
    .replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
async function login() {
  const verifier = randomVerifier();
  localStorage.setItem("pkce_verifier", verifier);
  const challenge = await sha256Base64Url(verifier);

  const url = "https://accounts.spotify.com/authorize?" + new URLSearchParams({
    response_type: "code",
    client_id: clientId,
    scope,
    redirect_uri: redirectUri,
    code_challenge_method: "S256",
    code_challenge: challenge,
    show_dialog: "true"
  });

  setDebug("Authorize URL:\n" + url);
  window.location = url;
}

/*** Spotify calls ***/
async function testMe() {
  setSetupStatus("Teste /me ‚Ä¶");
  try {
    const me = await apiGet("https://api.spotify.com/v1/me");
    setSetupStatus(`<span class="ok">‚úÖ /me ok: ${me.display_name}</span>`);
    setDebug(JSON.stringify(me, null, 2));
  } catch (e) {
    setSetupStatus(`<span class="bad">‚ùå ${e.message}</span>`);
    setDebug(e.stack || e.message);
  }
}

async function loadPlaylists() {
  setSetupStatus("Lade Playlists‚Ä¶");
  setDebug("");

  try {
    const data = await apiGet("https://api.spotify.com/v1/me/playlists?limit=50");
    const items = data.items || [];

    playlistList = items.map(pl => ({
      id: (pl.id || "").trim(),
      name: pl.name || "(ohne Namen)",
      total: (typeof pl.items?.total === "number") ? pl.items.total :
             (typeof pl.tracks?.total === "number") ? pl.tracks.total :
             null
    })).filter(p => p.id);

    setSetupStatus(`<span class="ok">‚úÖ ${playlistList.length} Playlists geladen</span>`);
    setDebug(JSON.stringify(playlistList.slice(0, 30), null, 2));
  } catch (e) {
    setSetupStatus(`<span class="bad">‚ùå ${e.message}</span>`);
    setDebug(e.stack || e.message);
  }
}

/*** Load ALL playlist items (pagination) ***/
async function loadAllTracksForPlaylist(playlistId) {
  const limit = 100;
  let offset = 0;
  let all = [];

  while (true) {
    const url =
      `https://api.spotify.com/v1/playlists/${encodeURIComponent(playlistId)}/items` +
      `?limit=${limit}&offset=${offset}&market=from_token` +
      `&fields=items(item(type,uri,id,name,artists(name),album(release_date))),total`;

    const data = await apiGet(url);
    const items = data.items || [];

    const tracks = items
      .map(x => x?.item ?? x?.track ?? null)
      .filter(t => t && t.type === "track")
      .filter(t => t.name && t.album?.release_date && t.artists?.length);

    all.push(...tracks);

    if (items.length < limit) break;
    offset += limit;
    if (offset > 20000) break;
  }

  return all;
}

/*** Playback control ***/
async function getActiveDeviceId() {
  const data = await apiGet("https://api.spotify.com/v1/me/player/devices");
  const devices = data.devices || [];
  const active = devices.find(d => d.is_active);
  if (active) return active.id;
  if (devices.length) return devices[0].id;
  return null;
}

async function pausePlayback() {
  const deviceId = await getActiveDeviceId();
  if (!deviceId) return;

  const res = await fetch(
    `https://api.spotify.com/v1/me/player/pause?device_id=${encodeURIComponent(deviceId)}`,
    { method: "PUT", headers: { Authorization: `Bearer ${getToken()}` } }
  );
  if (!res.ok && res.status !== 204) {
    const t = await res.text();
    throw new Error(`Stop/Pause fehlgeschlagen (${res.status}): ${t}`);
  }
  isPlaying = false;
  updateStopPlayBtn();
}

async function resumePlayback() {
  const deviceId = await getActiveDeviceId();
  if (!deviceId) {
    alert("Kein Spotify-Ger√§t gefunden. √ñffne Spotify (App/Webplayer) und starte kurz einen Song, dann nochmal.");
    return;
  }

  const res = await fetch(`https://api.spotify.com/v1/me/player/play?device_id=${encodeURIComponent(deviceId)}`, {
    method: "PUT",
    headers: { Authorization: `Bearer ${getToken()}` }
  });

  if (!res.ok && res.status !== 204) {
    const t = await res.text();
    throw new Error(`Resume fehlgeschlagen (${res.status}): ${t}`);
  }

  isPlaying = true;
  updateStopPlayBtn();
}

async function playTrack(track) {
  const deviceId = await getActiveDeviceId();
  if (!deviceId) {
    alert("Kein Spotify-Ger√§t gefunden. √ñffne Spotify (App/Webplayer) und starte kurz einen Song, dann nochmal.");
    return;
  }

  const uri = track.uri || (track.id ? `spotify:track:${track.id}` : null);
  if (!uri) { alert("Track hat keine URI/ID ‚Äì bitte Playlist neu laden."); return; }

  // optional: Ger√§t aktiv setzen
  await fetch(`https://api.spotify.com/v1/me/player`, {
    method: "PUT",
    headers: { Authorization: `Bearer ${getToken()}`, "Content-Type": "application/json" },
    body: JSON.stringify({ device_ids: [deviceId], play: true })
  });

  const res = await fetch(`https://api.spotify.com/v1/me/player/play?device_id=${encodeURIComponent(deviceId)}`, {
    method: "PUT",
    headers: { Authorization: `Bearer ${getToken()}`, "Content-Type": "application/json" },
    body: JSON.stringify({ uris: [uri] })
  });

  if (!res.ok && res.status !== 204) {
    const t = await res.text();
    throw new Error(`Play fehlgeschlagen (${res.status}): ${t}`);
  }

  isPlaying = true;
  updateStopPlayBtn();
}

/*** Setup UI ***/
function getSelectedMode(){
  const el = document.querySelector('input[name="mode"]:checked');
  return el ? el.value : "standard";
}

function buildPlayersForm() {
  const n = Math.max(1, Math.min(12, Number(document.getElementById("numPlayers").value || 1)));
  playersForm.innerHTML = "";

  if (!playlistList.length) {
    setSetupStatus(`<span class="bad">‚ùå Bitte zuerst "Meine Playlists laden".</span>`);
    return;
  }

  for (let i = 0; i < n; i++) {
    const row = document.createElement("div");
    row.className = "playerRow";
    row.innerHTML = `
      <b>Spieler ${i+1}</b>
      <input type="text" placeholder="Name" value="${i===0 ? "Papa" : i===1 ? "Mama" : "Spieler "+(i+1)}" data-field="name"/>
      <select data-field="playlist"></select>
    `;

    const sel = row.querySelector('select[data-field="playlist"]');
    playlistList.forEach(pl => {
      const opt = document.createElement("option");
      opt.value = pl.id;
      opt.textContent = pl.name;
      sel.appendChild(opt);
    });

    playersForm.appendChild(row);
  }

  setSetupStatus(`<span class="ok">‚úÖ Spielerfelder erstellt. W√§hle pro Spieler eine Playlist.</span>`);
}

function readPlayersFromForm() {
  const rows = Array.from(playersForm.querySelectorAll(".playerRow"));
  const out = rows.map(r => {
    const name = (r.querySelector('input[data-field="name"]').value || "").trim() || "Spieler";
    const playlistId = r.querySelector('select[data-field="playlist"]').value;
    return { name, playlistId, tracks: [], bag: [], timeline: [], score: 0 };
  });

  if (!out.length) throw new Error("Keine Spieler definiert.");
  if (out.some(p => !p.playlistId)) throw new Error("Mindestens ein Spieler hat keine Playlist.");

  return out;
}

/*** Shuffle-bag ***/
function refillBag(player) {
  const idx = Array.from({ length: player.tracks.length }, (_, i) => i);
  for (let i = idx.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [idx[i], idx[j]] = [idx[j], idx[i]];
  }
  player.bag = idx;
}
function drawSongForPlayer(player) {
  if (!player.tracks.length) throw new Error(`Playlist von ${player.name} hat keine Tracks.`);
  if (!player.bag.length) refillBag(player);
  return player.tracks[player.bag.pop()];
}

/*** Scoreboard ***/
function renderScoreboard() {
  scoreboardEl.innerHTML = "";
  players.forEach((p, idx) => {
    const chip = document.createElement("div");
    chip.className = "scorechip" + (idx === currentPlayerIndex ? " active" : "");
    const suffix = (mode === "standard") ? `(${p.score}/${WIN_SCORE_STANDARD})` : `(${p.score} Punkte)`;
    chip.textContent = `${p.name} ${suffix}`;
    scoreboardEl.appendChild(chip);
  });
}

/*** STANDARD MODE timeline UI ***/
function yearOf(song) {
  const y = Number((song.album?.release_date || "").slice(0,4));
  return Number.isFinite(y) ? y : null;
}

function isPlacementCorrect(candidateSong, timeline, pos) {
  const y = yearOf(candidateSong);
  if (y === null) return false;

  const left = (pos - 1 >= 0) ? yearOf(timeline[pos - 1].song) : null;
  const right = (pos < timeline.length) ? yearOf(timeline[pos].song) : null;

  const okLeft = (left === null) ? true : (left <= y);
  const okRight = (right === null) ? true : (y <= right);
  return okLeft && okRight;
}

function renderTimeline() {
  const p = players[currentPlayerIndex];
  timelineRow.innerHTML = "";

  const entries = p.timeline;
  const slotCount = entries.length + 1;

  for (let s = 0; s < slotCount; s++) {
    const slot = document.createElement("div");
    slot.className = "slot" + (phase === "placing" && s === insertPos ? " active" : "");
    const btn = document.createElement("button");
    btn.type = "button";
    btn.textContent = "‚îÇ";
    btn.onclick = () => {
      if (phase !== "placing") return;
      insertPos = s;
      renderTimeline();
      renderPlacementPanel();
    };
    slot.appendChild(btn);
    timelineRow.appendChild(slot);

    if (s < entries.length) {
      const e = entries[s];
      const card = document.createElement("div");
      card.className = "card";
      if (e.result === true) card.classList.add("ok");
      if (e.result === false) card.classList.add("bad");

      const year = (e.song.album.release_date || "").slice(0,4) || "?";
      const artists = e.song.artists.map(a=>a.name).join(", ");
      card.innerHTML = `<b>${e.song.name}</b><br>${artists}<br>Jahr: ${year}`;

      timelineRow.appendChild(card);
    }
  }
}

function renderPlacementPanel() {
  const p = players[currentPlayerIndex];
  if (phase === "placing") {
    placeControls.classList.remove("hidden");
    posLabel.textContent = `${insertPos} / ${p.timeline.length}`;
    leftBtn.disabled = insertPos <= 0;
    rightBtn.disabled = insertPos >= p.timeline.length;
  } else {
    placeControls.classList.add("hidden");
    posLabel.textContent = "";
  }
}

function moveInsert(dir) {
  const p = players[currentPlayerIndex];
  if (phase !== "placing") return;
  const next = insertPos + dir;
  if (next < 0 || next > p.timeline.length) return;
  insertPos = next;
  renderTimeline();
  renderPlacementPanel();
}

/*** GUESS MODE UI ***/
function resetGuessChecks(){
  chkTitle.checked = false;
  chkArtist.checked = false;
  chkYear.checked = false;
}

/*** Game flow ***/
function resetTurnUI() {
  currentSong = null;
  insertPos = 0;
  phase = "idle";
  isPlaying = false;
  updateStopPlayBtn();

  setGameStatus("");
  revealBox.classList.add("hidden");
  revealBox.innerHTML = "";

  guessRevealBox.classList.add("hidden");
  guessRevealBox.innerHTML = "";
  guessChecks.classList.add("hidden");
  resetGuessChecks();

  readyBtn.classList.remove("hidden");
  revealBtn.classList.add("hidden");
  applyPointsBtn.classList.add("hidden");
  nextBtn.classList.add("hidden");

  timelineArea.classList.toggle("hidden", mode !== "standard");
  guessArea.classList.toggle("hidden", mode !== "guess");

  if (mode === "standard") {
    renderTimeline();
    renderPlacementPanel();
  }

  endGameBtn.classList.toggle("hidden", mode !== "guess");
  renderScoreboard();
}

function showTurnPrompt() {
  const p = players[currentPlayerIndex];
  turnPrompt.textContent = `üé§ ${p.name} ist dran. Bereit?`;
  resetTurnUI();
}

/*** Smooth start on Ready ***/
async function onReady() {
  const p = players[currentPlayerIndex];
  currentSong = drawSongForPlayer(p);

  // Smooth: pause old first, tiny delay, then play new
  await pausePlayback().catch(()=>{});
  await sleep(180);

  try {
    await playTrack(currentSong);
  } catch (e) {
    setGameStatus("‚ùå " + e.message);
    setDebug(e.stack || e.message);
    return;
  }

  if (mode === "standard") {
    phase = "placing";
    insertPos = p.timeline.length;
    renderTimeline();
    renderPlacementPanel();
    setGameStatus("üéµ L√§uft‚Ä¶ Position w√§hlen (Slots/‚¨ÖÔ∏è‚û°Ô∏è), dann REVEAL!");
  } else {
    setGameStatus("üéµ L√§uft‚Ä¶ erraten: Titel / Interpret / Jahr. Dann REVEAL!");
  }

  readyBtn.classList.add("hidden");
  revealBtn.classList.remove("hidden");
}

/*** Reveal ***/
async function onReveal() {
  const p = players[currentPlayerIndex];
  if (!currentSong) return;

  try { await pausePlayback(); } catch {}

  const year = (currentSong.album.release_date || "").slice(0,4) || "?";
  const artists = currentSong.artists.map(a=>a.name).join(", ");

  if (mode === "standard") {
    let correct = (p.timeline.length === 0) ? true : isPlacementCorrect(currentSong, p.timeline, insertPos);

    if (correct) {
      p.timeline.splice(insertPos, 0, { song: currentSong, result: true });
      p.score += 1;

      if (p.score >= WIN_SCORE_STANDARD) {
        renderScoreboard();
        showWinner(`üèÜ Gewinner: ${p.name} (10 richtig)`, renderRankingHtml());
        return;
      }
      setGameStatus("‚úÖ Richtig! ‚û°Ô∏è Weiter");
    } else {
      setGameStatus("‚ùå Falsch (Karte verworfen). ‚û°Ô∏è Weiter");
    }

    revealBox.innerHTML =
      `<b>${currentSong.name}</b><br>${artists}<br>Jahr: ${year}<br><br>` +
      (correct ? `<span class="ok">‚úÖ Richtig platziert</span>` : `<span class="bad">‚ùå Falsch platziert</span>`);
    revealBox.classList.remove("hidden");

    phase = "revealed";
    renderTimeline();
    renderPlacementPanel();

    revealBtn.classList.add("hidden");
    nextBtn.classList.remove("hidden");
  } else {
    guessRevealBox.innerHTML = `<b>${currentSong.name}</b><br>${artists}<br>Jahr: ${year}`;
    guessRevealBox.classList.remove("hidden");
    guessChecks.classList.remove("hidden");

    revealBtn.classList.add("hidden");
    applyPointsBtn.classList.remove("hidden");
    setGameStatus("W√§hle aus, was richtig war, dann Punkte √ºbernehmen.");
  }

  renderScoreboard();
}

/*** Apply points (guess mode) ***/
function onApplyPoints() {
  const p = players[currentPlayerIndex];
  if (mode !== "guess") return;

  const pts = (chkTitle.checked ? 1 : 0) + (chkArtist.checked ? 1 : 0) + (chkYear.checked ? 1 : 0);
  p.score += pts;

  setGameStatus(`‚úÖ ${pts} Punkt(e) vergeben. ‚û°Ô∏è Weiter`);
  applyPointsBtn.classList.add("hidden");
  nextBtn.classList.remove("hidden");
  renderScoreboard();
}

/*** Next ***/
function onNext() {
  currentSong = null;
  insertPos = 0;
  phase = "idle";
  isPlaying = false;
  updateStopPlayBtn();

  currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
  showTurnPrompt();
}

/*** Ranking/End game ***/
function renderRankingHtml(){
  const sorted = [...players].sort((a,b)=>b.score-a.score);
  const rows = sorted.map((p,i)=> `<div><b>${i+1}.</b> ${p.name} ‚Äî ${p.score} ${mode==="standard"?"richtig":"Punkte"}</div>`).join("");
  return `<div>${rows}</div>`;
}

function endGame() {
  showWinner("üèÅ Spiel beendet ‚Äì Punktewertung", renderRankingHtml());
}

/*** Start game ***/
async function startGame() {
  if (!getToken()) {
    setSetupStatus(`<span class="bad">‚ùå Bitte zuerst mit Spotify verbinden.</span>`);
    return;
  }
  if (!playlistList.length) {
    setSetupStatus(`<span class="bad">‚ùå Bitte zuerst "Meine Playlists laden".</span>`);
    return;
  }

  mode = getSelectedMode();

  let chosen;
  try {
    chosen = readPlayersFromForm();
  } catch (e) {
    setSetupStatus(`<span class="bad">‚ùå ${e.message}</span>`);
    return;
  }

  setSetupStatus("‚è≥ Lade alle Playlists vollst√§ndig‚Ä¶");
  setDebug("");

  try {
    for (let i = 0; i < chosen.length; i++) {
      const p = chosen[i];
      setSetupStatus(`‚è≥ Lade Playlist f√ºr <b>${p.name}</b>‚Ä¶`);
      const tracks = await loadAllTracksForPlaylist(p.playlistId);
      p.tracks = tracks;
      p.bag = [];
      p.timeline = [];
      p.score = 0;
      setDebug(`Geladen f√ºr ${p.name}: ${tracks.length} Tracks\n` + (debugEl.textContent || ""));
    }
  } catch (e) {
    setSetupStatus(`<span class="bad">‚ùå Laden fehlgeschlagen: ${e.message}</span>`);
    setDebug(e.stack || e.message);
    return;
  }

  players = chosen;
  currentPlayerIndex = 0;
  currentSong = null;
  insertPos = 0;
  phase = "idle";
  isPlaying = false;
  updateStopPlayBtn();

  setSetupStatus(`<span class="ok">‚úÖ Fertig. Spiel startet!</span>`);
  showGame();
  renderScoreboard();
  showTurnPrompt();
}

/*** wire up ***/
document.getElementById("loginBtn").onclick = login;
document.getElementById("logoutBtn").onclick = logout;

document.getElementById("loadPlaylistsBtn").onclick = loadPlaylists;
document.getElementById("testMeBtn").onclick = testMe;
document.getElementById("buildPlayersBtn").onclick = buildPlayersForm;
document.getElementById("startGameBtn").onclick = startGame;

readyBtn.onclick = () => onReady().catch(e => { setGameStatus("‚ùå " + e.message); setDebug(e.stack || e.message); });
revealBtn.onclick = () => onReveal().catch(e => { setGameStatus("‚ùå " + e.message); setDebug(e.stack || e.message); });

applyPointsBtn.onclick = onApplyPoints;
nextBtn.onclick = onNext;

stopBtn.onclick = () => {
  const p = isPlaying ? pausePlayback : resumePlayback;
  p().catch(e => {
    setGameStatus("‚ùå " + e.message);
    setDebug(e.stack || e.message);
  });
};

leftBtn.onclick = () => moveInsert(-1);
rightBtn.onclick = () => moveInsert(+1);

endGameBtn.onclick = endGame;

document.getElementById("restartBtn").onclick = () => {
  players = [];
  currentSong = null;
  phase = "idle";
  insertPos = 0;
  currentPlayerIndex = 0;
  isPlaying = false;
  updateStopPlayBtn();
  showSetup();
  setGameStatus("");
  setDebug("");
};

refreshConnStatus();
updateStopPlayBtn();
showSetup();
</script>

</body>
</html>
