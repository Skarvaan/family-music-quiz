<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Family Music Quiz</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 920px; margin: 24px auto; padding: 0 12px; }
    button { padding: 10px 12px; margin: 6px 6px 6px 0; cursor:pointer; }
    select, input { padding: 8px; margin: 6px 6px 6px 0; }
    .box { border: 1px solid #ddd; padding: 12px; border-radius: 10px; margin-top: 12px; }
    .ok { color: #0a7a0a; }
    .bad { color: #b00020; }
    .muted { color:#666; font-size: 12px; }
    pre { white-space: pre-wrap; word-break: break-word; background:#fafafa; border:1px solid #eee; padding:10px; border-radius:8px; }
  </style>
</head>
<body>

<h1>Family Music Quiz</h1>

<div class="box">
  <h2>1) Verbindung</h2>
  <button id="loginBtn">Mit Spotify verbinden</button>
  <button id="logoutBtn">Logout (Token l√∂schen)</button>
  <div id="connStatus"></div>
</div>

<div class="box">
  <h2>2) Playlists</h2>
  <button id="loadPlaylistsBtn">Meine Playlists laden</button>
  <button id="testMeBtn">/me testen</button>
  <div id="playlistStatus"></div>

  <div id="playlistsUI" style="display:none;">
    <p><b>Gefundene Playlists:</b></p>
    <select id="playlistSelect" style="min-width: 340px;"></select>
    <button id="testPlaylistBtn">Zugriff testen</button>
    <button id="loadItemsBtn">Items in Playlist laden</button>
  </div>
</div>

<div class="box">
  <h2>3) Runde</h2>
  <button id="drawBtn">üé≤ Zuf√§lligen Song ziehen</button>
  <button id="revealBtn">üëÄ Reveal</button>
  <button id="playBtn">‚ñ∂Ô∏è Play in Spotify</button>
  <button id="stopBtn">‚è∏Ô∏è Stop</button>
  <p id="drawStatus"></p>
  <div id="revealBox" style="display:none; margin-top:10px;"></div>
  <div class="muted">Hinweis: Erst ‚ÄúItems laden‚Äù, dann ziehen.</div>
</div>

<div class="box">
  <h2>4) Debug</h2>
  <pre id="debug"></pre>
</div>

<script>
/*** ‚úÖ KONFIG ***/
const clientId = "1567cc8cfec14ea2b8562efca5dd7e08";
const redirectUri = "https://skarvaan.github.io/family-music-quiz/callback.html";

/*** Scopes (erstmal nur Playlists, Playback sp√§ter) ***/
const scope = [
  "playlist-read-private",
  "playlist-read-collaborative",
  "user-read-playback-state",
  "user-modify-playback-state"
].join(" ");

/*** UI refs ***/
const connStatus = document.getElementById("connStatus");
const playlistStatus = document.getElementById("playlistStatus");
const debugEl = document.getElementById("debug");
const playlistsUI = document.getElementById("playlistsUI");
const playlistSelect = document.getElementById("playlistSelect");
const drawStatus = document.getElementById("drawStatus");
const revealBox = document.getElementById("revealBox");

/*** State ***/
let currentTracks = [];
let currentSong = null;

/*** helpers ***/
function setDebug(msg) { debugEl.textContent = msg || ""; }
function setConn(html) { connStatus.innerHTML = html; }
function setPlaylistStatus(html) { playlistStatus.innerHTML = html; }

function getToken() { return localStorage.getItem("spotify_access_token"); }
function getScope() { return localStorage.getItem("spotify_scope") || ""; }

function logout() {
  localStorage.removeItem("spotify_access_token");
  localStorage.removeItem("spotify_scope");
  localStorage.removeItem("pkce_verifier");
  localStorage.removeItem("spotify_auth_code");

  currentTracks = [];
  currentSong = null;

  playlistsUI.style.display = "none";
  playlistSelect.innerHTML = "";
  drawStatus.textContent = "";
  revealBox.style.display = "none";
  revealBox.innerHTML = "";

  setPlaylistStatus("üîí Token gel√∂scht.");
  setDebug("");
  refreshConnStatus();
}

function refreshConnStatus() {
  const s = getScope();
  setConn(getToken()
    ? `<span class="ok">‚úÖ Verbunden (Token vorhanden)</span><br><small>Scopes: ${s || "(unbekannt)"}</small>`
    : `<span class="bad">‚ùå Nicht verbunden</span>`
  );
}

/*** fetch with timeout + error detail ***/
async function apiGet(url, timeoutMs = 12000) {
  const token = getToken();
  if (!token) throw new Error("Kein Token vorhanden (bitte neu verbinden).");

  const ctrl = new AbortController();
  const timer = setTimeout(() => ctrl.abort(), timeoutMs);

  try {
    const res = await fetch(url, {
      headers: { Authorization: `Bearer ${token}` },
      signal: ctrl.signal
    });

    const text = await res.text();
    let data = null;
    try { data = text ? JSON.parse(text) : null; } catch {}

    if (!res.ok) {
      const msg = data?.error?.message || data?.error_description || text || `HTTP ${res.status}`;
      throw new Error(`Spotify API Fehler (${res.status}): ${msg}`);
    }
    return data;
  } catch (e) {
    if (e.name === "AbortError") throw new Error("Timeout: Spotify antwortet nicht (12s).");
    throw e;
  } finally {
    clearTimeout(timer);
  }
}

/*** PKCE login ***/
function randomVerifier() {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const bytes = crypto.getRandomValues(new Uint8Array(64));
  return Array.from(bytes, b => chars[b % chars.length]).join("");
}

async function sha256Base64Url(verifier) {
  const digest = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(verifier));
  return btoa(String.fromCharCode(...new Uint8Array(digest)))
    .replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}

async function login() {
  const verifier = randomVerifier();
  localStorage.setItem("pkce_verifier", verifier);
  const challenge = await sha256Base64Url(verifier);

  const url = "https://accounts.spotify.com/authorize?" + new URLSearchParams({
    response_type: "code",
    client_id: clientId,
    scope,
    redirect_uri: redirectUri,
    code_challenge_method: "S256",
    code_challenge: challenge,
    show_dialog: "true"   // erzwingt Consent Screen
  });

  setDebug("Authorize URL:\n" + url);
  window.location = url;
}

/*** API actions ***/
async function testMe() {
  setPlaylistStatus("Teste /me ‚Ä¶");
  setDebug("");
  try {
    const me = await apiGet("https://api.spotify.com/v1/me");
    setPlaylistStatus(`<span class="ok">‚úÖ /me ok: ${me.display_name}</span>`);
    setDebug(JSON.stringify(me, null, 2));
  } catch (e) {
    setPlaylistStatus(`<span class="bad">‚ùå /me Fehler: ${e.message}</span>`);
    setDebug(e.stack || e.message);
  }
}

async function loadPlaylists() {
  setPlaylistStatus("Lade Playlists‚Ä¶");
  setDebug("");

  try {
    const data = await apiGet("https://api.spotify.com/v1/me/playlists?limit=50");
    const items = data.items || [];
    playlistSelect.innerHTML = "";

    if (!items.length) {
      setPlaylistStatus("‚ö†Ô∏è Keine Playlists gefunden.");
      setDebug(JSON.stringify(data, null, 2));
      return;
    }

    items.forEach(pl => {
      const opt = document.createElement("option");

      // ID: robust (zur Sicherheit)
      opt.value = (pl.id || "").trim();

      // total: manche Accounts liefern tracks oder items oder gar nichts
      const total =
        (typeof pl.items?.total === "number") ? pl.items.total :
        (typeof pl.tracks?.total === "number") ? pl.tracks.total :
        "?";

      const name = pl.name || "(ohne Namen)";
      opt.textContent = `${name} (${total} Tracks)`;

      // falls vorhanden, tracks-href merken (manchmal stabiler)
      opt.dataset.tracksHref = pl.tracks?.href || "";
      opt.dataset.itemsHref  = pl.items?.href  || "";

      playlistSelect.appendChild(opt);
    });

    if (playlistSelect.options.length > 0) playlistSelect.selectedIndex = 0;

    playlistsUI.style.display = "block";
    setPlaylistStatus(`<span class="ok">‚úÖ ${items.length} Playlists geladen</span>`);
    setDebug(JSON.stringify(items.map(p => ({name:p.name, id:p.id, tracks_total:p.tracks?.total, items_total:p.items?.total})), null, 2));
  } catch (e) {
    setPlaylistStatus(`<span class="bad">‚ùå ${e.message}</span>`);
    setDebug(e.stack || e.message);
  }
}

async function testPlaylistAccess() {
  const id = (playlistSelect.value || "").trim();
  setDebug("Ausgew√§hlte Playlist-ID:\n" + id);

  if (!id) {
    setPlaylistStatus("‚ùå Keine Playlist ausgew√§hlt.");
    return;
  }

  const url = `https://api.spotify.com/v1/playlists/${encodeURIComponent(id)}?market=from_token`;
  setPlaylistStatus("Teste Playlist-Zugriff‚Ä¶");

  try {
    const data = await apiGet(url);
    setPlaylistStatus(`<span class="ok">‚úÖ Zugriff ok: ${data.name}</span>`);
    setDebug(JSON.stringify({
      name: data.name,
      owner: data.owner?.display_name,
      public: data.public,
      tracks_total: data.tracks?.total
    }, null, 2));
  } catch (e) {
    setPlaylistStatus(`<span class="bad">‚ùå ${e.message}</span>`);
    setDebug(e.stack || e.message);
  }
}

/*** Ìïµ Fix: Playlist-Inhalte √ºber /items laden (nicht /tracks) ***/
async function loadItemsFromPlaylist() {
  const id = (playlistSelect.value || "").trim();
  if (!id) {
    setPlaylistStatus("‚ùå Keine Playlist ausgew√§hlt.");
    return;
  }

  setPlaylistStatus("Lade Items‚Ä¶");
  setDebug("");

  // Minimaler & stabiler Request (Felder reduzieren)
  const url =
  `https://api.spotify.com/v1/playlists/${encodeURIComponent(id)}/items` +
  `?limit=100&market=from_token` +
  `&fields=items(item(type,uri,id,name,artists(name),album(release_date))),total`;
  setDebug("Items-URL:\n" + url);

  try {
    const data = await apiGet(url);
    const items = data.items || [];

    // kompatibel: item (neu), track (alt)
    currentTracks = items
      .map(x => x?.item ?? x?.track ?? null)
      .filter(t => t && t.type === "track")
      .filter(t => t.name && t.album?.release_date && t.artists?.length);

    if (!currentTracks.length) {
      setPlaylistStatus("‚ö†Ô∏è Keine Tracks gefunden (evtl. nur Podcasts/leer/track=null).");
      setDebug("Antwort (gek√ºrzt):\n" + JSON.stringify({
        total: data.total,
        sample: items.slice(0, 5)
      }, null, 2));
      return;
    }

    setPlaylistStatus(`<span class="ok">‚úÖ ${currentTracks.length} Tracks geladen</span>`);
    setDebug(JSON.stringify(currentTracks.slice(0, 10).map(t => ({
      name: t.name,
      artists: t.artists.map(a => a.name).join(", "),
      year: (t.album.release_date || "").slice(0,4)
    })), null, 2));
  } catch (e) {
    setPlaylistStatus(`<span class="bad">‚ùå ${e.message}</span>`);
    setDebug(e.stack || e.message);
  }
}

/*** Game: draw + reveal ***/
function drawRandomSong() {
  if (!currentTracks.length) {
    alert("Erst Items/Tracks laden!");
    return;
  
  }
  const index = Math.floor(Math.random() * currentTracks.length);
  currentSong = currentTracks[index];
  pausePlayback().catch(()=>{});
  revealBox.style.display = "none";
  revealBox.innerHTML = "";
  drawStatus.textContent = "üéµ Song gew√§hlt ‚Äì jetzt raten!";
}

async function revealSong() {
  if (!currentSong) return;

  // üî• automatisch stoppen (aber leise, wenn es nicht geht)
  try {
    await pausePlayback();
  } catch (e) {
    // nicht hart abbrechen ‚Äì Reveal soll trotzdem gehen
    setDebug("Pause beim Reveal fehlgeschlagen:\n" + (e.stack || e.message));
  }

  const year = (currentSong.album?.release_date || "").slice(0, 4) || "?";
  const artists = (currentSong.artists || []).map(a => a.name).join(", ");

  revealBox.innerHTML = `<b>${currentSong.name}</b><br>${artists}<br>Jahr: ${year}`;
  revealBox.style.display = "block";
}

  async function getActiveDeviceId() {
  const data = await apiGet("https://api.spotify.com/v1/me/player/devices");
  const devices = data.devices || [];

  // bevorzugt: aktives Ger√§t
  const active = devices.find(d => d.is_active);
  if (active) return active.id;

  // sonst: irgendeins nehmen
  if (devices.length) return devices[0].id;

  return null;
}

async function playCurrentSong() {
  if (!currentSong) {
    alert("Erst einen Song ziehen!");
    return;
  }

  // Spotify muss irgendwo offen sein (App/Webplayer), sonst gibt‚Äôs 404/403
  const deviceId = await getActiveDeviceId();
  if (!deviceId) {
    alert("Kein Spotify-Ger√§t gefunden. √ñffne Spotify (App oder Webplayer) und starte irgendeinen Song, dann nochmal.");
    return;
  }

  // Track-URI ist n√∂tig (z.B. "spotify:track:...")
  const uri = currentSong.uri || (currentSong.id ? `spotify:track:${currentSong.id}` : null);
if (!uri) {
  alert("Track hat keine URI/ID ‚Äì bitte Items neu laden.");
  return;
}

  async function pausePlayback() {
  const deviceId = await getActiveDeviceId();
  if (!deviceId) {
    // wenn kein Device aktiv ist, einfach still failen (oder Meldung)
    setPlaylistStatus("‚ÑπÔ∏è Kein aktives Spotify-Ger√§t zum Stoppen gefunden.");
    return;
  }

  const res = await fetch(`https://api.spotify.com/v1/me/player/pause?device_id=${encodeURIComponent(deviceId)}`, {
    method: "PUT",
    headers: { Authorization: `Bearer ${getToken()}` }
  });

  if (!res.ok && res.status !== 204) {
    const t = await res.text();
    throw new Error(`Stop/Pause fehlgeschlagen (${res.status}): ${t}`);
  }

  setPlaylistStatus("‚è∏Ô∏è Pausiert.");
}

  // optional: erst Ger√§t aktiv setzen
  await fetch(`https://api.spotify.com/v1/me/player`, {
    method: "PUT",
    headers: { Authorization: `Bearer ${getToken()}`, "Content-Type": "application/json" },
    body: JSON.stringify({ device_ids: [deviceId], play: true })
  });

  // dann Track abspielen
  const res = await fetch(`https://api.spotify.com/v1/me/player/play?device_id=${encodeURIComponent(deviceId)}`, {
    method: "PUT",
    headers: { Authorization: `Bearer ${getToken()}`, "Content-Type": "application/json" },
    body: JSON.stringify({ uris: [uri] })
  });

  if (!res.ok && res.status !== 204) {
    const t = await res.text();
    throw new Error(`Play fehlgeschlagen (${res.status}): ${t}`);
  }

  setPlaylistStatus("‚ñ∂Ô∏è Spielt in Spotify‚Ä¶");
}

/*** wire up ***/
document.getElementById("loginBtn").onclick = login;
document.getElementById("logoutBtn").onclick = logout;
document.getElementById("loadPlaylistsBtn").onclick = loadPlaylists;
document.getElementById("testMeBtn").onclick = testMe;
document.getElementById("testPlaylistBtn").onclick = testPlaylistAccess;
document.getElementById("loadItemsBtn").onclick = loadItemsFromPlaylist;
document.getElementById("drawBtn").onclick = drawRandomSong;
document.getElementById("revealBtn").onclick = revealSong;
  document.getElementById("playBtn").onclick = () => {
  playCurrentSong().catch(e => {
    setPlaylistStatus("‚ùå " + e.message);
    setDebug(e.stack || e.message);
  });
};
document.getElementById("stopBtn").onclick = () => {
  pausePlayback().catch(e => {
    setPlaylistStatus("‚ùå " + e.message);
    setDebug(e.stack || e.message);
  });
};

refreshConnStatus();
</script>

</body>
</html>
