<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Family Music Quiz</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 1100px; margin: 24px auto; padding: 0 12px; }
    button { padding: 10px 12px; margin: 6px 6px 6px 0; cursor:pointer; }
    select, input { padding: 8px; margin: 6px 6px 6px 0; }
    .box { border: 1px solid #ddd; padding: 12px; border-radius: 10px; margin-top: 12px; }
    .ok { color: #0a7a0a; }
    .bad { color: #b00020; }
    .muted { color:#666; font-size: 12px; }
    pre { white-space: pre-wrap; word-break: break-word; background:#fafafa; border:1px solid #eee; padding:10px; border-radius:8px; }
    .row { display:flex; gap:10px; flex-wrap: wrap; align-items: center; }
    .hidden { display:none !important; }
    .big { font-size: 22px; font-weight: 700; margin: 8px 0; }

    .playerRow { display:flex; gap:10px; flex-wrap: wrap; align-items:center; margin: 8px 0; padding: 8px; border: 1px dashed #ddd; border-radius: 10px; }
    .playerRow input { width: 180px; }
    .playerRow select { min-width: 360px; }

    /* Timeline UI */
    .timelineWrap { overflow-x:auto; padding-bottom: 6px; }
    .timeline { display:flex; align-items: stretch; gap: 10px; min-height: 74px; }
    .card {
      min-width: 190px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid #ddd;
      background: #fff;
    }
    .card.ok { border-color: #0a7a0a; }
    .card.bad { border-color: #b00020; }
    .slot {
      min-width: 30px;
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius: 10px;
      border: 2px dashed #ddd;
      background: #fafafa;
      user-select: none;
    }
    .slot button{
      margin:0;
      padding: 14px 10px;
      width: 100%;
      border: none;
      background: transparent;
      font-size: 18px;
      cursor:pointer;
    }
    .slot.active { border-color: #111; background:#f0f0f0; }
    .slot:hover { background:#f3f3f3; }

    .scoreboard { display:flex; gap:10px; flex-wrap:wrap; }
    .scorechip { border:1px solid #ddd; border-radius:999px; padding:6px 10px; background:#fff; }
    .scorechip.active { border-color:#111; }
  </style>
</head>
<body>

<h1>Family Music Quiz</h1>

<div class="box">
  <h2>1) Verbindung</h2>
  <button id="loginBtn">Mit Spotify verbinden</button>
  <button id="logoutBtn">Logout (Token l√∂schen)</button>
  <div id="connStatus"></div>
</div>

<!-- SETUP SCREEN -->
<div id="setupScreen" class="box">
  <h2>2) Setup</h2>

  <div class="row">
    <button id="loadPlaylistsBtn">Meine Playlists laden</button>
    <button id="testMeBtn">/me testen</button>
  </div>

  <div id="setupStatus"></div>

  <div class="box" style="margin-top:10px;">
    <b>Hinweis zu geteilten Playlists:</b>
    <div class="muted">
      Geteilte/‚ÄûShared‚Äú Playlists erscheinen hier, wenn du sie in Spotify <b>folgst / speicherst</b>
      oder wenn es eine <b>collaborative Playlist</b> ist.
    </div>
  </div>

  <div class="row" style="margin-top:10px;">
    <label><b>Anzahl Spieler:</b></label>
    <input id="numPlayers" type="number" min="1" max="12" value="3" />
    <button id="buildPlayersBtn">Spielerfelder erstellen</button>
  </div>

  <div id="playersForm"></div>

  <div class="row" style="margin-top:12px;">
    <button id="startGameBtn">Spiel starten</button>
    <span class="muted">Start l√§dt automatisch alle gew√§hlten Playlists vollst√§ndig (kann bei gro√üen Listen dauern).</span>
  </div>
</div>

<!-- GAME SCREEN -->
<div id="gameScreen" class="box hidden">
  <h2>3) Spiel</h2>

  <div class="row" style="justify-content:space-between;">
    <div id="turnPrompt" class="big"></div>
    <div class="scoreboard" id="scoreboard"></div>
  </div>

  <div id="turnButtons" class="row">
    <button id="readyBtn">‚úÖ Bereit</button>
    <button id="revealBtn" class="hidden">üëÄ Reveal</button>
    <button id="nextBtn" class="hidden">‚û°Ô∏è Weiter</button>
    <button id="stopBtn">‚è∏Ô∏è Stop</button>
  </div>

  <div id="gameStatus" class="muted"></div>

  <div id="timelineArea" class="box" style="margin-top:10px;">
    <div class="muted">Timeline (f√ºr den aktuellen Spieler):</div>
    <div class="timelineWrap">
      <div id="timelineRow" class="timeline"></div>
    </div>

    <div class="row" id="placeControls" style="margin-top:10px;">
      <button id="leftBtn">‚¨ÖÔ∏è</button>
      <div class="box" style="flex:1; margin:0;">
        <b>Neue Karte (verdeckt):</b>
        <div id="candidateCard" class="muted" style="margin-top:6px;">‚Äì</div>
        <div class="muted">Einf√ºgeposition: <span id="posLabel"></span></div>
        <div class="muted">Tipp: Klicke auf eine gestrichelte Linie (Slot), um die Position zu √§ndern.</div>
      </div>
      <button id="rightBtn">‚û°Ô∏è</button>
    </div>

    <div id="revealBox" class="box hidden" style="margin-top:10px;"></div>
  </div>
</div>

<!-- WINNER SCREEN -->
<div id="winnerScreen" class="box hidden">
  <h2>üèÅ Spiel beendet</h2>
  <div id="winnerText" class="big"></div>
  <button id="restartBtn">Neues Spiel (Setup)</button>
</div>

<div class="box">
  <h2>Debug</h2>
  <pre id="debug"></pre>
</div>

<script>
/*** ‚úÖ KONFIG ***/
const clientId = "1567cc8cfec14ea2b8562efca5dd7e08";
const redirectUri = "https://skarvaan.github.io/family-music-quiz/callback.html";
const WIN_SCORE = 10;

const scope = [
  "playlist-read-private",
  "playlist-read-collaborative",
  "user-read-playback-state",
  "user-modify-playback-state"
].join(" ");

/*** UI refs ***/
const connStatus = document.getElementById("connStatus");
const debugEl = document.getElementById("debug");

const setupScreen = document.getElementById("setupScreen");
const setupStatus = document.getElementById("setupStatus");
const playersForm = document.getElementById("playersForm");

const gameScreen = document.getElementById("gameScreen");
const winnerScreen = document.getElementById("winnerScreen");
const winnerText = document.getElementById("winnerText");

const turnPrompt = document.getElementById("turnPrompt");
const gameStatus = document.getElementById("gameStatus");
const scoreboardEl = document.getElementById("scoreboard");

const timelineRow = document.getElementById("timelineRow");
const candidateCard = document.getElementById("candidateCard");
const posLabel = document.getElementById("posLabel");

const revealBox = document.getElementById("revealBox");
const placeControls = document.getElementById("placeControls");

const readyBtn = document.getElementById("readyBtn");
const revealBtn = document.getElementById("revealBtn");
const nextBtn = document.getElementById("nextBtn");
const stopBtn = document.getElementById("stopBtn");
const leftBtn = document.getElementById("leftBtn");
const rightBtn = document.getElementById("rightBtn");

/*** State ***/
// Playlists from Spotify:
let playlistList = []; // [{id,name,total}]

// Players:
let players = []; // [{name, playlistId, tracks:[], bag:[], timeline:[], score:number}]
let currentPlayerIndex = 0;

// Candidate (current round):
let currentSong = null;      // track object
let insertPos = 0;           // 0..timeline.length
let phase = "idle";          // "idle" | "placing" | "revealed"

/*** helpers ***/
function setDebug(msg) { debugEl.textContent = msg || ""; }
function setConn(html) { connStatus.innerHTML = html; }
function setSetupStatus(html) { setupStatus.innerHTML = html; }
function setGameStatus(msg) { gameStatus.textContent = msg || ""; }

function getToken() { return localStorage.getItem("spotify_access_token"); }
function getScope() { return localStorage.getItem("spotify_scope") || ""; }

window.onerror = function(message, source, lineno, colno) {
  setDebug("JS ERROR:\n" + message + "\n" + source + ":" + lineno + ":" + colno);
};

function refreshConnStatus() {
  const s = getScope();
  setConn(getToken()
    ? `<span class="ok">‚úÖ Verbunden (Token vorhanden)</span><br><small>Scopes: ${s || "(unbekannt)"}</small>`
    : `<span class="bad">‚ùå Nicht verbunden</span>`
  );
}

function showSetup(){
  setupScreen.classList.remove("hidden");
  gameScreen.classList.add("hidden");
  winnerScreen.classList.add("hidden");
}

function showGame(){
  setupScreen.classList.add("hidden");
  gameScreen.classList.remove("hidden");
  winnerScreen.classList.add("hidden");
}

function showWinner(name){
  setupScreen.classList.add("hidden");
  gameScreen.classList.add("hidden");
  winnerScreen.classList.remove("hidden");
  winnerText.textContent = `üèÜ Gewinner: ${name} (10 richtige Karten)`;
}

function logout() {
  localStorage.removeItem("spotify_access_token");
  localStorage.removeItem("spotify_scope");
  localStorage.removeItem("pkce_verifier");
  localStorage.removeItem("spotify_auth_code");

  playlistList = [];
  players = [];
  currentPlayerIndex = 0;

  currentSong = null;
  insertPos = 0;
  phase = "idle";

  playersForm.innerHTML = "";
  setSetupStatus("üîí Token gel√∂scht.");
  setGameStatus("");
  revealBox.classList.add("hidden");
  revealBox.innerHTML = "";
  timelineRow.innerHTML = "";
  setDebug("");
  showSetup();
  refreshConnStatus();
}

/*** fetch helper ***/
async function apiGet(url, timeoutMs = 20000) {
  const token = getToken();
  if (!token) throw new Error("Kein Token vorhanden (bitte neu verbinden).");

  const ctrl = new AbortController();
  const timer = setTimeout(() => ctrl.abort(), timeoutMs);

  try {
    const res = await fetch(url, {
      headers: { Authorization: `Bearer ${token}` },
      signal: ctrl.signal
    });

    const text = await res.text();
    let data = null;
    try { data = text ? JSON.parse(text) : null; } catch {}

    if (!res.ok) {
      const msg = data?.error?.message || data?.error_description || text || `HTTP ${res.status}`;
      throw new Error(`Spotify API Fehler (${res.status}): ${msg}`);
    }
    return data;
  } catch (e) {
    if (e.name === "AbortError") throw new Error("Timeout: Spotify antwortet nicht (20s).");
    throw e;
  } finally {
    clearTimeout(timer);
  }
}

/*** PKCE login ***/
function randomVerifier() {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const bytes = crypto.getRandomValues(new Uint8Array(64));
  return Array.from(bytes, b => chars[b % chars.length]).join("");
}
async function sha256Base64Url(verifier) {
  const digest = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(verifier));
  return btoa(String.fromCharCode(...new Uint8Array(digest)))
    .replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
async function login() {
  const verifier = randomVerifier();
  localStorage.setItem("pkce_verifier", verifier);
  const challenge = await sha256Base64Url(verifier);

  const url = "https://accounts.spotify.com/authorize?" + new URLSearchParams({
    response_type: "code",
    client_id: clientId,
    scope,
    redirect_uri: redirectUri,
    code_challenge_method: "S256",
    code_challenge: challenge,
    show_dialog: "true"
  });

  setDebug("Authorize URL:\n" + url);
  window.location = url;
}

/*** Spotify calls ***/
async function testMe() {
  setSetupStatus("Teste /me ‚Ä¶");
  try {
    const me = await apiGet("https://api.spotify.com/v1/me");
    setSetupStatus(`<span class="ok">‚úÖ /me ok: ${me.display_name}</span>`);
    setDebug(JSON.stringify(me, null, 2));
  } catch (e) {
    setSetupStatus(`<span class="bad">‚ùå ${e.message}</span>`);
    setDebug(e.stack || e.message);
  }
}

async function loadPlaylists() {
  setSetupStatus("Lade Playlists‚Ä¶");
  setDebug("");

  try {
    const data = await apiGet("https://api.spotify.com/v1/me/playlists?limit=50");
    const items = data.items || [];

    playlistList = items.map(pl => ({
      id: (pl.id || "").trim(),
      name: pl.name || "(ohne Namen)",
      total: (typeof pl.items?.total === "number") ? pl.items.total :
             (typeof pl.tracks?.total === "number") ? pl.tracks.total :
             null
    })).filter(p => p.id);

    setSetupStatus(`<span class="ok">‚úÖ ${playlistList.length} Playlists geladen</span>`);
    setDebug(JSON.stringify(playlistList.slice(0, 30), null, 2));
  } catch (e) {
    setSetupStatus(`<span class="bad">‚ùå ${e.message}</span>`);
    setDebug(e.stack || e.message);
  }
}

/*** Load ALL playlist items (pagination) ***/
async function loadAllTracksForPlaylist(playlistId) {
  const limit = 100;
  let offset = 0;
  let all = [];

  while (true) {
    const url =
      `https://api.spotify.com/v1/playlists/${encodeURIComponent(playlistId)}/items` +
      `?limit=${limit}&offset=${offset}&market=from_token` +
      `&fields=items(item(type,uri,id,name,artists(name),album(release_date))),total`;

    const data = await apiGet(url);
    const items = data.items || [];

    const tracks = items
      .map(x => x?.item ?? x?.track ?? null)
      .filter(t => t && t.type === "track")
      .filter(t => t.name && t.album?.release_date && t.artists?.length);

    all.push(...tracks);

    if (items.length < limit) break;
    offset += limit;

    if (offset > 20000) break; // safety
  }

  return all;
}

/*** Playback control ***/
async function getActiveDeviceId() {
  const data = await apiGet("https://api.spotify.com/v1/me/player/devices");
  const devices = data.devices || [];
  const active = devices.find(d => d.is_active);
  if (active) return active.id;
  if (devices.length) return devices[0].id;
  return null;
}

async function pausePlayback() {
  const deviceId = await getActiveDeviceId();
  if (!deviceId) { setGameStatus("‚ÑπÔ∏è Kein aktives Spotify-Ger√§t zum Stoppen gefunden."); return; }

  const res = await fetch(
    `https://api.spotify.com/v1/me/player/pause?device_id=${encodeURIComponent(deviceId)}`,
    { method: "PUT", headers: { Authorization: `Bearer ${getToken()}` } }
  );
  if (!res.ok && res.status !== 204) {
    const t = await res.text();
    throw new Error(`Stop/Pause fehlgeschlagen (${res.status}): ${t}`);
  }
  setGameStatus("‚è∏Ô∏è Pausiert.");
}

async function playTrack(track) {
  const deviceId = await getActiveDeviceId();
  if (!deviceId) {
    alert("Kein Spotify-Ger√§t gefunden. √ñffne Spotify (App/Webplayer) und starte kurz einen Song, dann nochmal.");
    return;
  }

  const uri = track.uri || (track.id ? `spotify:track:${track.id}` : null);
  if (!uri) { alert("Track hat keine URI/ID ‚Äì bitte Playlist neu laden."); return; }

  // optional: Ger√§t aktiv setzen
  await fetch(`https://api.spotify.com/v1/me/player`, {
    method: "PUT",
    headers: { Authorization: `Bearer ${getToken()}`, "Content-Type": "application/json" },
    body: JSON.stringify({ device_ids: [deviceId], play: true })
  });

  const res = await fetch(`https://api.spotify.com/v1/me/player/play?device_id=${encodeURIComponent(deviceId)}`, {
    method: "PUT",
    headers: { Authorization: `Bearer ${getToken()}`, "Content-Type": "application/json" },
    body: JSON.stringify({ uris: [uri] })
  });

  if (!res.ok && res.status !== 204) {
    const t = await res.text();
    throw new Error(`Play fehlgeschlagen (${res.status}): ${t}`);
  }
}

/*** Setup UI ***/
function buildPlayersForm() {
  const n = Math.max(1, Math.min(12, Number(document.getElementById("numPlayers").value || 1)));
  playersForm.innerHTML = "";

  if (!playlistList.length) {
    setSetupStatus(`<span class="bad">‚ùå Bitte zuerst "Meine Playlists laden".</span>`);
    return;
  }

  for (let i = 0; i < n; i++) {
    const row = document.createElement("div");
    row.className = "playerRow";
    row.innerHTML = `
      <b>Spieler ${i+1}</b>
      <input type="text" placeholder="Name" value="${i===0 ? "Papa" : i===1 ? "Mama" : "Spieler "+(i+1)}" data-field="name"/>
      <select data-field="playlist"></select>
    `;

    const sel = row.querySelector('select[data-field="playlist"]');
    playlistList.forEach(pl => {
      const opt = document.createElement("option");
      opt.value = pl.id;
      opt.textContent = pl.name;
      sel.appendChild(opt);
    });

    playersForm.appendChild(row);
  }

  setSetupStatus(`<span class="ok">‚úÖ Spielerfelder erstellt. W√§hle pro Spieler eine Playlist.</span>`);
}

function readPlayersFromForm() {
  const rows = Array.from(playersForm.querySelectorAll(".playerRow"));
  const out = rows.map(r => {
    const name = (r.querySelector('input[data-field="name"]').value || "").trim() || "Spieler";
    const playlistId = r.querySelector('select[data-field="playlist"]').value;
    return { name, playlistId, tracks: [], bag: [], timeline: [], score: 0 };
  });

  if (!out.length) throw new Error("Keine Spieler definiert.");
  if (out.some(p => !p.playlistId)) throw new Error("Mindestens ein Spieler hat keine Playlist.");

  return out;
}

/*** Shuffle-bag (gegen Wiederholungen) ***/
function refillBag(player) {
  const idx = Array.from({ length: player.tracks.length }, (_, i) => i);
  for (let i = idx.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [idx[i], idx[j]] = [idx[j], idx[i]];
  }
  player.bag = idx;
}
function drawSongForPlayer(player) {
  if (!player.tracks.length) throw new Error(`Playlist von ${player.name} hat keine Tracks.`);
  if (!player.bag.length) refillBag(player);
  return player.tracks[player.bag.pop()];
}

/*** Timeline + placement UI ***/
function hiddenCandidateText() {
  // Wenn du lieber Titel/Artist zeigen willst (wie Hitster), √§ndere das hier.
  return "üéµ Unbekannter Song (verdeckt)";
}

function renderScoreboard() {
  scoreboardEl.innerHTML = "";
  players.forEach((p, idx) => {
    const chip = document.createElement("div");
    chip.className = "scorechip" + (idx === currentPlayerIndex ? " active" : "");
    chip.textContent = `${p.name}: ${p.score}/${WIN_SCORE}`;
    scoreboardEl.appendChild(chip);
  });
}

function renderTimeline() {
  const p = players[currentPlayerIndex];
  timelineRow.innerHTML = "";

  const entries = p.timeline; // revealed entries only

  // slots count = entries.length + 1
  const slotCount = entries.length + 1;

  for (let s = 0; s < slotCount; s++) {
    // slot
    const slot = document.createElement("div");
    slot.className = "slot" + (phase === "placing" && s === insertPos ? " active" : "");
    const btn = document.createElement("button");
    btn.type = "button";
    btn.textContent = "‚îÇ";
    btn.onclick = () => {
      if (phase !== "placing") return;
      insertPos = s;
      renderTimeline();
      renderPlacementPanel();
    };
    slot.appendChild(btn);
    timelineRow.appendChild(slot);

    // card after slot, except after last slot
    if (s < entries.length) {
      const e = entries[s];
      const card = document.createElement("div");
      card.className = "card";
      if (e.result === true) card.classList.add("ok");
      if (e.result === false) card.classList.add("bad");

      if (!e.revealed) {
        card.innerHTML = `<b>${hiddenCandidateText()}</b><br><span class="muted">(verdeckt)</span>`;
      } else {
        const year = (e.song.album.release_date || "").slice(0,4) || "?";
        const artists = e.song.artists.map(a=>a.name).join(", ");
        card.innerHTML = `<b>${e.song.name}</b><br>${artists}<br>Jahr: ${year}`;
      }
      timelineRow.appendChild(card);
    }
  }
}

function renderPlacementPanel() {
  const p = players[currentPlayerIndex];

  if (phase === "placing") {
    placeControls.classList.remove("hidden");
    candidateCard.textContent = hiddenCandidateText();
    posLabel.textContent = `${insertPos} / ${p.timeline.length}`;
    leftBtn.disabled = insertPos <= 0;
    rightBtn.disabled = insertPos >= p.timeline.length;
  } else {
    placeControls.classList.add("hidden");
    candidateCard.textContent = "‚Äì";
    posLabel.textContent = "";
  }
}

function moveInsert(dir) {
  const p = players[currentPlayerIndex];
  if (phase !== "placing") return;
  const next = insertPos + dir;
  if (next < 0 || next > p.timeline.length) return;
  insertPos = next;
  renderTimeline();
  renderPlacementPanel();
}

/*** Placement correctness ***/
function yearOf(song) {
  const y = Number((song.album?.release_date || "").slice(0,4));
  return Number.isFinite(y) ? y : null;
}

function isPlacementCorrect(candidateSong, timeline, pos) {
  // timeline = revealed entries only
  // pos = insertion index (0..timeline.length)

  const y = yearOf(candidateSong);
  if (y === null) return false;

  const left = (pos - 1 >= 0) ? yearOf(timeline[pos - 1].song) : null;
  const right = (pos < timeline.length) ? yearOf(timeline[pos].song) : null;

  // Gleichheit erlaubt => <=
  const okLeft = (left === null) ? true : (left <= y);
  const okRight = (right === null) ? true : (y <= right);

  return okLeft && okRight;
}

/*** Game flow ***/
function resetTurnUI() {
  revealBox.classList.add("hidden");
  revealBox.innerHTML = "";
  readyBtn.classList.remove("hidden");
  revealBtn.classList.add("hidden");
  nextBtn.classList.add("hidden");
  phase = "idle";
  currentSong = null;
  insertPos = 0;
  renderTimeline();
  renderPlacementPanel();
  renderScoreboard();
}

function showTurnPrompt() {
  const p = players[currentPlayerIndex];
  turnPrompt.textContent = `üé§ ${p.name} ist dran. Bereit?`;
  setGameStatus("");
  resetTurnUI();
}

async function onReady() {
  const p = players[currentPlayerIndex];

  // Song ziehen
  currentSong = drawSongForPlayer(p);

  // Song starten
  try {
    await playTrack(currentSong);
  } catch (e) {
    setGameStatus("‚ùå " + e.message);
    setDebug(e.stack || e.message);
    return;
  }

  // Placement: erster Song "frei" => wir lassen ihn platzieren, aber Position irrelevant
  phase = "placing";
  insertPos = p.timeline.length; // default: ans Ende (kann per Slot ge√§ndert werden)

  renderTimeline();
  renderPlacementPanel();

  readyBtn.classList.add("hidden");
  revealBtn.classList.remove("hidden");
  nextBtn.classList.add("hidden");

  setGameStatus("üéµ L√§uft‚Ä¶ w√§hle die Position (Slots oder ‚¨ÖÔ∏è/‚û°Ô∏è), dann Reveal.");
}

async function onReveal() {
  const p = players[currentPlayerIndex];
  if (!currentSong) return;

  // stop
  try { await pausePlayback(); } catch {}

  // Pr√ºfen
  let correct;
  if (p.timeline.length === 0) {
    // erster Song z√§hlt immer als richtig
    correct = true;
  } else {
    correct = isPlacementCorrect(currentSong, p.timeline, insertPos);
  }

  if (correct) {
    // Karte bleibt: wir f√ºgen sie an insertPos ein
    const entry = { song: currentSong, revealed: true, result: true };
    p.timeline.splice(insertPos, 0, entry);
    p.score += 1;

    // Winner?
    if (p.score >= WIN_SCORE) {
      renderScoreboard();
      showWinner(p.name);
      return;
    }

    setGameStatus("‚úÖ Richtig! ‚û°Ô∏è Weiter");
  } else {
    // Karte wird entfernt/verworfen
    setGameStatus("‚ùå Falsch (Karte verworfen). ‚û°Ô∏è Weiter");
  }

  // Reveal Box anzeigen
  const year = (currentSong.album.release_date || "").slice(0,4) || "?";
  const artists = currentSong.artists.map(a=>a.name).join(", ");
  revealBox.innerHTML =
    `<b>${currentSong.name}</b><br>${artists}<br>Jahr: ${year}<br><br>` +
    (correct ? `<span class="ok">‚úÖ Richtig platziert</span>` : `<span class="bad">‚ùå Falsch platziert</span>`);
  revealBox.classList.remove("hidden");

  // UI
  phase = "revealed";
  revealBtn.classList.add("hidden");
  nextBtn.classList.remove("hidden");
  placeControls.classList.add("hidden");

  renderTimeline();
  renderScoreboard();
}

function onNext() {
  currentSong = null;
  insertPos = 0;
  phase = "idle";
  revealBox.classList.add("hidden");
  revealBox.innerHTML = "";

  currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
  showTurnPrompt();
}

/*** Start game: load all chosen playlists automatically ***/
async function startGame() {
  if (!getToken()) {
    setSetupStatus(`<span class="bad">‚ùå Bitte zuerst mit Spotify verbinden.</span>`);
    return;
  }
  if (!playlistList.length) {
    setSetupStatus(`<span class="bad">‚ùå Bitte zuerst "Meine Playlists laden".</span>`);
    return;
  }

  let chosen;
  try {
    chosen = readPlayersFromForm();
  } catch (e) {
    setSetupStatus(`<span class="bad">‚ùå ${e.message}</span>`);
    return;
  }

  setSetupStatus("‚è≥ Lade alle Playlists vollst√§ndig‚Ä¶ (bei gro√üen Playlists dauert es etwas)");
  setDebug("");

  try {
    for (let i = 0; i < chosen.length; i++) {
      const p = chosen[i];
      setSetupStatus(`‚è≥ Lade Playlist f√ºr <b>${p.name}</b>‚Ä¶`);
      const tracks = await loadAllTracksForPlaylist(p.playlistId);
      p.tracks = tracks;
      p.bag = [];
      p.timeline = [];
      p.score = 0;
      setDebug(`Geladen f√ºr ${p.name}: ${tracks.length} Tracks\n` + (debugEl.textContent || ""));
    }
  } catch (e) {
    setSetupStatus(`<span class="bad">‚ùå Laden fehlgeschlagen: ${e.message}</span>`);
    setDebug(e.stack || e.message);
    return;
  }

  players = chosen;
  currentPlayerIndex = 0;
  currentSong = null;
  insertPos = 0;
  phase = "idle";

  setSetupStatus(`<span class="ok">‚úÖ Fertig. Spiel startet!</span>`);
  showGame();
  renderScoreboard();
  showTurnPrompt();
}

/*** wire up ***/
document.getElementById("loginBtn").onclick = login;
document.getElementById("logoutBtn").onclick = logout;

document.getElementById("loadPlaylistsBtn").onclick = loadPlaylists;
document.getElementById("testMeBtn").onclick = testMe;
document.getElementById("buildPlayersBtn").onclick = buildPlayersForm;
document.getElementById("startGameBtn").onclick = startGame;

readyBtn.onclick = () => onReady().catch(e => { setGameStatus("‚ùå " + e.message); setDebug(e.stack || e.message); });
revealBtn.onclick = () => onReveal().catch(e => { setGameStatus("‚ùå " + e.message); setDebug(e.stack || e.message); });
nextBtn.onclick = onNext;

stopBtn.onclick = () => pausePlayback().catch(e => { setGameStatus("‚ùå " + e.message); setDebug(e.stack || e.message); });

leftBtn.onclick = () => moveInsert(-1);
rightBtn.onclick = () => moveInsert(+1);

document.getElementById("restartBtn").onclick = () => {
  // Spiel reset, aber Token behalten
  players = [];
  currentSong = null;
  phase = "idle";
  insertPos = 0;
  currentPlayerIndex = 0;
  showSetup();
  setGameStatus("");
  revealBox.classList.add("hidden");
  revealBox.innerHTML = "";
  timelineRow.innerHTML = "";
  renderScoreboard();
};

refreshConnStatus();
showSetup();
</script>

</body>
</html>
